/* Main.c file generated by New Project wizard
 *
 * Created:   周四 6月 29 2017
 * Processor: AT89C52
 * Compiler:  Keil for 8051
 */

/**--------------------------------------------------------------------
 * @file	main.c

 * @version	V1.0
 
 * @author	周文青

 * @date	2017/6/30
 
 * @brief	电机编码器测速设计程序
	 
 * @target processor	芯片：STC89C51/STC89C52/STC89C51RC/STC89C52RC
			晶振：11.0592MHz
 * @description
	 
	 IO配置: 		
		time:占空比，初值设定为10，即将一个PWM周期分为10份
		P20:motor1:pwm1，控制 L298 芯片的IN1
		P21:motor2:pwm2，控制 L298 芯片的IN2
		P34:按键方向切换及启动
		P35:停止
		P36:加速
		P37:减速
				
		P1[0-7]:连接LCD D[0-7]数据位
		P02: 	LCD的RS
		P01:	LCD的RW
		P00:	LCD的EN
	
	 PWM:
	       电机信号控制停止时为双高电平，故当使用示波器进行PWM波形测量时需要注意调节PWM是指调节某信号脚低电平占空比；
	       由定时器1产生，定时器1工作方式，16位定时，向上计数
					12           12
			 机器周期 T0 = ------- = --------------s
				       fosc     11.0592*10^6
			
			定时时间 T = (65536-Num)×T0
			Num就是 TH1和TL0的值，将这个数值分为高8位和低8位
			高位	TH1 = (65536-Num)/256
			低位	TL1 = (65536-Num)%256
			
			
	 测速原理：
	       使用定时器0和外部中断0，使能定时器0中断和外部中断0
	       外部中断接在P3^2引脚 
	       每当检测到外部脉冲，计数值加1，计时满1s后，进入定时器0中断处理函数，把计数值提出来，同时把计数值复位
	       
      程序开始-> |	   定时满1s|
	       |----------------->|------>{RQ_Handle中断处理
	       |		  |
	       |		  |
	       |/\/\/\/\/\/\/\/\/\|
	       |	脉冲	  |	
	       
	       
	       
	       * @attention: 	
				 1.本程序允许只有发布和修改，但修改者必须开放源代码，不管是用于商业或非商业用途
				 2.若本程序用于商业用途，因为程序BUG产生的损失不负任何责任

--------------------------------------------------------------------------------------------*/


#include <reg52.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef unsigned char uchar;
typedef unsigned int uint;
sbit m1 = P2^0;		//pwm信号1
sbit m2 = P2^1;		//pwm信号2
sbit key1 = P3^4;		//方向切换及启动
sbit key2 = P3^5;		//停止
sbit key3 = P3^6;		//加速
sbit key4 = P3^7;		//减速

sbit BUTTON0 = P3^2;	//外部中断0
sbit BUTTON1 = P3^3;	//外部中断1

sbit RS = P0^2;
sbit RW = P0^1;
sbit EN = P0^0;
sbit relay = P0^3;
sbit led  = P2^7;

unsigned char flag=1,sflag=0;		//flag：转向标志，1为正转、0为翻转
																//sflag：启动标志，1为转动状态、0为停止状态
unsigned int s1=0,t1;				//s1：定时器中断计数
int time=10;		
int freq,num;
char cnt=0;		// 计数值
uint pp; 
					//time：占空比（0~10）
void delayms(unsigned int xms); //微秒级延时函数
void key();			//按键功能函数
void Initial();	   		//初始化函数,包括定时器0（中断），定时器1，外部中断
void Read_Busy(); 		//读写检查函数
void Write_Cmd(uchar cmd);  	//写指令函数
void Write_Dat(uchar dat);  	//写入数据
void LCD1602_Init();		//LCD初始化
void PrintStr(char *str);	// LCD输出字符串
void DisplayNum(int m);		// LCD显示数值
void delay(unsigned int x);

/*****************主函数***********************/
void main()
{
  
   m1=1;
   m2=1;
  
   Initial();		// 初始化定时器0，1，外部中断
   LCD1602_Init();  	// 初始化LCD1602
   relay = 0;		// 正常工作情况下继电器不能得电
   led = 0;
   while(1)
   {
     key();

      Write_Cmd(0x80 | 0x00);	// 显示第1行
     PrintStr("Speed:");
		 //freq = freq/6-25;
     DisplayNum(freq);
		 //delay(2);
	PrintStr("RPM");
     Write_Cmd(0xc0| 0x00);	// 显示第二行
     PrintStr("Duty:");
     DisplayNum(time*10);
     Write_Dat('%');
              
   }
}



/************初始化函数****************
 *
 * 功能描述：实现对定时器0，定时器1，外部中断1中断
 *
 ************************************/
void Initial()
{
   TMOD=0X11;	//设置定时器0 和 定时器1，工作方式1，16为定时
	
   TH1 = 0XFC;	//定时器0初值1ms
   TL1 = 0X66;
   IP = 0X00;	// 中断优先级控制

   TH0 = 0x4c;	//定时器1初值50ms
   TL0 = 0X00;
   
   EX0 = 1;		// 开启外部中断0，默认中断优先级为0
   EX1 = 1;
   IT0 = 1;		// 外部中断触发方式为脉冲触发
   TR0 = 1;		// 定时器0启动由后面启动
   //TR1 = 1;		// 定时器1用来参数PWM波，按下启动按钮后才启动
   ET0 = 1;		//开定时器0中断
   ET1 = 1;
   EA=1;		//开总中断
}

/********************************************
 *
 * 函数描述：定时器0中断函数
 *
 ********************************************/

void timer1() interrupt 3 
{
	TH1=0XFC;	
	TL1=0X66;
	s1++;
	if(s1<=time)
	{
		if(flag==1)
		{
			m1=1;
			m2=0;
		}
		else
		{
			m1=0;
			m2=1;
		}
	}
	else
	{
		m1=1;
		m2=1;
	}
	if(s1==10)
	{
		s1=0;
	}	
}


void timer0() interrupt 1
{
   TH0 = 0x4C;	//定时器1初值50ms
   TL0 = 0X00;
   
   pp++;
   
   if(pp ==20)	//计时满 1s
   {
     freq = num/6-25;	//获取1s内中断计数的值，
      if(freq<=0)
	 freq=0;
     num = 0;
     //cnt++;
     //led = ~led;
     pp = 0;
   }
}
      
void extern_int0(void) interrupt 0 
{

   //led = ~led;
   num ++;
   
}
/*
//判断液晶忙，如果忙则等待，因为1602也是一个CPU，要处理原来的指令，如果不判断会导致数据紊乱
void Read_Busy() //读写检查函数
{
    uchar busy;
    P1 = 0xFF;   //P0口作为数据端
    RS = 0;         
    RW = 1;             //读状态的操作时序为 RS=L,RW=H,E=H,D0~D7输出状态字
    do
    {
        EN = 1;
        busy = P1;
        EN = 0;
    }while(busy & 0x80); 
    //状态字为busy（8位2进制数）的最高位，
    //若为1则禁止读写，为0则允许读写，该状态用busy&0x80的结果表示
}

*/


/*******************************************
 * 
 * 函数描述：写指令函数
 * 
 *******************************************/
void Write_Cmd(uchar cmd)  //写指令函数
{
    //Read_Busy();	//对控制器每次进行读写操作都要判断是否正忙，即要进行读写检测
   P1 = cmd;   	//写入十六进制形式的指令（command）
   RS = 0;
   EN = 0;
   delay(10);
   
   EN = 1;     	//写指令的操作时序：RS=0,RW=0,EN=高脉冲
   delay(10);
   EN = 0;         	//获得高脉冲后使能端重新置零
}


void Write_Dat(uchar dat)  //写入数据
{
   // Read_Busy(); 	//写入数据前进行读写检测
   P1 = dat;    	//P0口写入数据
   RS = 1;
   EN = 0;
    
   delay(10);
    
   EN = 1;          	//写数据操作时序：RS=0,RW=0,EN=高脉冲
   delay(10);
   EN = 0;          	//获得高脉冲后使能端重新置零
}

void LCD1602_Init()
{
   RW = 0;
   Write_Cmd(0x38);//设置16*2显示
   delay(8);
   Write_Cmd(0x0f);//开显示 显示光标，光标闪烁
   delay(8);
   Write_Cmd(0x01);//清屏
   delay(8);
   Write_Cmd(0x06);//地址指针移位命令
   delay(8);
    //Write_Cmd(0x80 | 0x00);//显示地址，0x80是第一行的的首地址。0x80|0x06表示数据从第一行第7个字符位置开始显示
    
}


void PrintStr(char *str)	// LCD输出字符串
{
   
   char i,len;
   len = strlen(str); 		// 获取字符串长度
   for(i=0;i<len;i++)
   {
      Write_Dat(*str);
      str++;
   }
}

void DisplayNum(int m)		// LCD显示数值
{

   int disdata[4];		// 显示占空比的数值，存到此数组
   disdata[0] = m/1000+0x30;
   disdata[1] = m%1000/100+0x30;
   disdata[2] = m%100/10+0x30;
   disdata[3] = m%10+0x30;
   
   if(disdata[0]==0x30)		//如果千位为0，让LCD不显示，0x30和0x20可以查询ACSII码表
   {
      disdata[0]=0x20;
      if( disdata[1]==0x30)		//如果百位为0，让LCD不显示，0x30和0x20可以查询ACSII码表
      {
	 disdata[1]=0x20;
	 if( disdata[2]==0x30)		//如果百位为0，让LCD不显示，0x30和0x20可以查询ACSII码表
	 {
	    disdata[2]=0x20;
	 }
      }
   }
	 
   Write_Dat(disdata[0]);
   delay(4);
   Write_Dat(disdata[1]);
   delay(4);
   Write_Dat(disdata[2]);
   delay(4);
   Write_Dat(disdata[3]);
   delay(4);
   
  
}

/********************************************
 *
 * 按键功能函数
 *
 *******************************************/
void key()
{
	if(key1==0)		//转向及启动
	{
		delayms(5);
		if(key1==0)
		{
			while(key1==0);
			if(sflag==1)		//为了实现停止后再启动保持之前的转向
			{
				flag=!flag;
				TR1=1;
			}
			else
			{
				TR1=1;
				sflag=1;
			}
		}
	}
	else if(key2==0)		//停止
	{
		delayms(5);
		if(key2==0)
		{
			while(key2==0);
			relay=1;	//反接制动
			TR1=0;
			m1=1;
			m2=1;
			sflag=0;
		}
	}
	else if(key3==0)		//加速
	{
		delayms(5);
		if(key3==0)
		{
			while(key3==0);
			if(time>=10)
				time=10;
			else
				time++;
		}
	}
	else if(key4==0)		//减速
	{
		delayms(5);
		if(key4==0)
		{
			while(key4==0);
			if(time==0)
				time=0;
			else
				time--;
		}
	}
}


/********************************************

 ***************延时函数**********************/
void delayms(unsigned int xms)
{
	unsigned int i,j;
	for(i=xms;i>0;i--)
		for(j=110;j>0;j--);
}


void delay(unsigned int x)
{
	unsigned int a,b;
	for(a=x;a>0;a--)
		for(b=10;b>0;b--); 
}